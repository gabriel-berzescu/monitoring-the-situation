<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Moltbook Growth Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      min-height: 100vh;
      background: #0b0b10;
      color: #eee;
      font-family: 'Space Grotesk', sans-serif;
      padding: 32px 24px;
    }

    .container { max-width: 720px; margin: 0 auto; }

    /* Header */
    .status-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }
    .status-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      animation: pulse 2s ease-in-out infinite;
    }
    .status-dot.ok   { background: #4caf50; box-shadow: 0 0 8px #4caf5088; }
    .status-dot.err  { background: #f44336; box-shadow: 0 0 8px #f4433688; }
    .status-dot.load { background: #ffa726; box-shadow: 0 0 8px #ffa72688; }

    .status-label {
      font-size: 11px; color: #666;
      text-transform: uppercase; letter-spacing: 2px;
      font-family: 'JetBrains Mono', monospace;
    }
    h1 { font-size: 32px; font-weight: 700; letter-spacing: -0.5px; }
    .subtitle {
      color: #555; font-size: 13px; margin-top: 6px;
      font-family: 'JetBrains Mono', monospace;
    }

    /* Cards */
    .cards { display: flex; flex-direction: column; gap: 16px; margin-top: 28px; }

    .card {
      background: rgba(20, 20, 28, 0.7);
      border-radius: 12px;
      padding: 20px 20px 12px 20px;
      border: 1px solid rgba(255,255,255,0.06);
      position: relative;
      overflow: hidden;
    }
    .card-gradient-line {
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 2px;
      opacity: 0.7;
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }
    .metric-label {
      font-size: 11px; color: #666;
      text-transform: uppercase; letter-spacing: 1.5px;
      font-family: 'JetBrains Mono', monospace;
    }
    .metric-value {
      font-size: 26px; font-weight: 700; color: #eee;
      font-family: 'Space Grotesk', sans-serif;
      margin-top: 2px;
    }
    .delta-badge {
      font-size: 13px; font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      padding: 3px 8px;
      border-radius: 6px;
    }
    .window-label {
      font-size: 10px; color: #555; margin-top: 4px;
      font-family: 'JetBrains Mono', monospace;
      text-align: right;
    }
    .chart-wrap { height: 180px; }

    /* Loading / Error states */
    .state-box {
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      height: 300px; gap: 12px;
      color: #555;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }
    .spinner {
      width: 24px; height: 24px;
      border: 2px solid #555;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .error-box {
      padding: 16px 20px;
      background: rgba(244,67,54,0.08);
      border: 1px solid rgba(244,67,54,0.2);
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: #f44336;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-top: 20px;
      margin-bottom: -8px;
      background: rgba(20, 20, 28, 0.5);
      border-radius: 10px;
      padding: 4px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .tab-btn {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      background: transparent;
      color: #555;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .tab-btn:hover {
      color: #888;
      background: rgba(255,255,255,0.04);
    }
    .tab-btn.active {
      background: rgba(255,255,255,0.08);
      color: #eee;
    }

    /* Daily sub-toggle */
    .daily-toggle {
      display: flex;
      justify-content: flex-end;
      margin-top: 12px;
      margin-bottom: -4px;
    }
    .daily-toggle .toggle-group {
      display: flex;
      gap: 2px;
      background: rgba(20, 20, 28, 0.5);
      border-radius: 6px;
      padding: 2px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .daily-toggle .toggle-btn {
      padding: 5px 12px;
      border: none;
      border-radius: 5px;
      background: transparent;
      color: #555;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .daily-toggle .toggle-btn:hover {
      color: #888;
      background: rgba(255,255,255,0.04);
    }
    .daily-toggle .toggle-btn.active {
      background: rgba(255,255,255,0.08);
      color: #eee;
    }

    /* Footer */
    .footer {
      margin-top: 24px;
      padding: 12px 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.05);
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: #555;
      text-align: center;
    }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
    @keyframes spin  { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div style="margin-bottom: 28px;">
      <div class="status-row">
        <div id="status-dot" class="status-dot load"></div>
        <span class="status-label">Monitoring the Situation</span>
      </div>
      <h1>Moltbook Growth</h1>
      <p id="subtitle" class="subtitle" style="display:none;"></p>
    </div>

    <!-- State containers -->
    <div id="loading" class="state-box">
      <div class="spinner"></div>
      Fetching from GitHub...
    </div>
    <div id="error" class="error-box" style="display:none;"></div>

    <!-- Tabs -->
    <div id="tabs" class="tabs" style="display:none;">
      <button class="tab-btn active" data-tab="timeline">Timeline</button>
      <button class="tab-btn" data-tab="daily-avg">Daily Average</button>
      <button class="tab-btn" data-tab="daily-datapoints">Daily Datapoints</button>
    </div>

    <!-- Daily sub-toggle -->
    <div id="daily-toggle" class="daily-toggle" style="display:none;">
      <div class="toggle-group">
        <button class="toggle-btn active" data-mode="absolute">Absolute</button>
        <button class="toggle-btn" data-mode="pct-change">% Change</button>
      </div>
    </div>

    <!-- Charts -->
    <div id="cards" class="cards" style="display:none;"></div>

    <!-- Footer -->
    <div id="footer" class="footer" style="display:none;">
      data pulled live from repo · points positioned by actual timestamp · github.com/gabriel-berzescu/monitoring-the-situation
    </div>
  </div>

<script>
const CSV_URL = 'https://raw.githubusercontent.com/gabriel-berzescu/monitoring-the-situation/main/data/stats.csv';
const MAX_DAILY_DAYS = 28;

const METRICS = [
  { key: 'agents',   label: 'Agents',   color: '#e8553d', gradient: ['#e8553d','#ff8a65'] },
  { key: 'submolts', label: 'Submolts', color: '#7c4dff', gradient: ['#7c4dff','#b388ff'] },
  { key: 'posts',    label: 'Posts',    color: '#00bfa5', gradient: ['#00bfa5','#64ffda'] },
  { key: 'comments', label: 'Comments', color: '#ffa726', gradient: ['#ffa726','#ffcc80'] },
];

/* ── helpers ── */
function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split(',');
  return lines.slice(1).map(line => {
    const vals = line.split(',');
    const row = {};
    headers.forEach((h, i) => row[h.trim()] = vals[i]?.trim());
    return {
      time: new Date(row.timestamp).getTime(),
      agents:   parseInt(row.agents, 10),
      submolts: parseInt(row.submolts, 10),
      posts:    parseInt(row.posts, 10),
      comments: parseInt(row.comments, 10),
    };
  });
}

function formatNumber(n) {
  if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toString();
}

function formatFull(n) { return n.toLocaleString(); }

function formatDateUTC(ts) {
  const d = new Date(ts);
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return months[d.getUTCMonth()] + ' ' + d.getUTCDate() + ', ' +
    String(d.getUTCHours()).padStart(2,'0') + ':' +
    String(d.getUTCMinutes()).padStart(2,'0') + ' UTC';
}

function computeWindowLabel(data) {
  const ms = data[data.length - 1].time - data[0].time;
  const hours = Math.round(ms / 3600000);
  if (hours < 48) return '~' + hours + 'h window';
  return '~' + Math.round(hours / 24) + 'd window';
}

function generateTicks(timeMin, timeMax) {
  const ticks = [];
  const start = new Date(timeMin);
  start.setUTCMinutes(0, 0, 0);
  let t = start.getTime();
  while (t <= timeMax + 3600000) {
    if (t >= timeMin - 1800000) ticks.push(t);
    t += 3 * 3600000;
  }
  return ticks;
}

function spansMultipleDays(data) {
  const first = new Date(data[0].time);
  const last = new Date(data[data.length - 1].time);
  return first.getUTCDate() !== last.getUTCDate() ||
         first.getUTCMonth() !== last.getUTCMonth();
}

function tickLabel(ts, multiDay) {
  const d = new Date(ts);
  const hh = String(d.getUTCHours()).padStart(2, '0');
  const mm = String(d.getUTCMinutes()).padStart(2, '0');
  if (!multiDay) return hh + ':' + mm;
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return months[d.getUTCMonth()] + ' ' + d.getUTCDate() + ' ' + hh + ':' + mm;
}

/* ── daily average helpers ── */
function getDayKey(ts) {
  const d = new Date(ts);
  return d.getUTCFullYear() + '-' +
    String(d.getUTCMonth() + 1).padStart(2, '0') + '-' +
    String(d.getUTCDate()).padStart(2, '0');
}

function getDayLabel(dayKey) {
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const parts = dayKey.split('-');
  return months[parseInt(parts[1], 10) - 1] + ' ' + parseInt(parts[2], 10);
}

function computeDailyAverages(data) {
  const buckets = {};
  data.forEach(d => {
    const key = getDayKey(d.time);
    if (!buckets[key]) buckets[key] = [];
    buckets[key].push(d);
  });

  const days = Object.keys(buckets).sort();
  const recent = days.slice(-MAX_DAILY_DAYS);

  return recent.map(day => {
    const points = buckets[day];
    const avg = {};
    METRICS.forEach(m => {
      const sum = points.reduce((s, p) => s + p[m.key], 0);
      avg[m.key] = Math.round(sum / points.length);
    });
    return { day: day, label: getDayLabel(day), samples: points.length, ...avg };
  });
}

/* ── build a timeline card (existing) ── */
function buildTimelineCard(metric, data) {
  const values = data.map(d => d[metric.key]);
  const min = Math.min(...values);
  const max = Math.max(...values);
  const pad = (max - min) * 0.08;
  const delta = values[values.length - 1] - values[0];
  const pct = ((delta / values[0]) * 100).toFixed(1);
  const windowLabel = computeWindowLabel(data);

  const timeMin = data[0].time;
  const timeMax = data[data.length - 1].time;
  const ticks = generateTicks(timeMin, timeMax);
  const multiDay = spansMultipleDays(data);

  const card = document.createElement('div');
  card.className = 'card';

  const gradLine = document.createElement('div');
  gradLine.className = 'card-gradient-line';
  gradLine.style.background = 'linear-gradient(90deg,' + metric.gradient[0] + ',' + metric.gradient[1] + ')';
  card.appendChild(gradLine);

  const header = document.createElement('div');
  header.className = 'card-header';
  header.innerHTML =
    '<div>' +
      '<div class="metric-label">' + metric.label + '</div>' +
      '<div class="metric-value">' + formatNumber(values[values.length - 1]) + '</div>' +
    '</div>' +
    '<div>' +
      '<div class="delta-badge" style="color:' + metric.color + ';background:' + metric.color + '15;">+' +
        formatNumber(delta) + ' (' + pct + '%)</div>' +
      '<div class="window-label">' + windowLabel + '</div>' +
    '</div>';
  card.appendChild(header);

  const wrap = document.createElement('div');
  wrap.className = 'chart-wrap';
  const canvas = document.createElement('canvas');
  wrap.appendChild(canvas);
  card.appendChild(wrap);

  const ctx = canvas.getContext('2d');
  const gradient = ctx.createLinearGradient(0, 0, 0, 180);
  gradient.addColorStop(0, metric.color + '40');
  gradient.addColorStop(1, metric.color + '05');

  new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [{
        data: data.map(d => ({ x: d.time, y: d[metric.key] })),
        borderColor: metric.color,
        borderWidth: 2.5,
        backgroundColor: gradient,
        fill: true,
        pointRadius: 3,
        pointBackgroundColor: metric.color,
        pointBorderWidth: 0,
        pointHoverRadius: 5,
        pointHoverBackgroundColor: metric.color,
        pointHoverBorderColor: '#0f0f14',
        pointHoverBorderWidth: 2,
        tension: 0.35,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(15, 15, 20, 0.95)',
          borderColor: metric.color + '44',
          borderWidth: 1,
          cornerRadius: 8,
          padding: { top: 10, bottom: 10, left: 14, right: 14 },
          titleFont: { family: "'JetBrains Mono', monospace", size: 12, weight: '400' },
          titleColor: '#888',
          bodyFont: { family: "'JetBrains Mono', monospace", size: 16, weight: '700' },
          bodyColor: metric.color,
          displayColors: false,
          callbacks: {
            title: function(items) { return formatDateUTC(items[0].parsed.x); },
            label: function(item) { return formatFull(item.parsed.y); }
          }
        }
      },
      scales: {
        x: {
          type: 'linear',
          min: timeMin,
          max: timeMax,
          afterBuildTicks: function(axis) { axis.ticks = ticks.map(v => ({ value: v })); },
          ticks: {
            callback: function(v) { return tickLabel(v, multiDay); },
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxRotation: 0,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { color: 'rgba(255,255,255,0.08)' },
        },
        y: {
          min: min - pad,
          max: max + pad,
          ticks: {
            callback: function(v) { return formatNumber(v); },
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxTicksLimit: 5,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { display: false },
        }
      },
      interaction: { mode: 'nearest', axis: 'x', intersect: false },
    }
  });

  return card;
}

/* ── build a daily average bar card ── */
function buildDailyAvgCard(metric, dailyData) {
  const values = dailyData.map(d => d[metric.key]);
  const labels = dailyData.map(d => d.label);
  const min = Math.min(...values);
  const max = Math.max(...values);
  const pad = (max - min) * 0.08 || max * 0.05;

  const overallAvg = Math.round(values.reduce((s, v) => s + v, 0) / values.length);
  const dayCount = dailyData.length;

  const card = document.createElement('div');
  card.className = 'card';

  const gradLine = document.createElement('div');
  gradLine.className = 'card-gradient-line';
  gradLine.style.background = 'linear-gradient(90deg,' + metric.gradient[0] + ',' + metric.gradient[1] + ')';
  card.appendChild(gradLine);

  const header = document.createElement('div');
  header.className = 'card-header';
  header.innerHTML =
    '<div>' +
      '<div class="metric-label">' + metric.label + '</div>' +
      '<div class="metric-value">' + formatNumber(overallAvg) + ' avg</div>' +
    '</div>' +
    '<div>' +
      '<div class="delta-badge" style="color:' + metric.color + ';background:' + metric.color + '15;">' +
        dayCount + ' day' + (dayCount !== 1 ? 's' : '') + '</div>' +
      '<div class="window-label">daily average</div>' +
    '</div>';
  card.appendChild(header);

  const wrap = document.createElement('div');
  wrap.className = 'chart-wrap';
  const canvas = document.createElement('canvas');
  wrap.appendChild(canvas);
  card.appendChild(wrap);

  const ctx = canvas.getContext('2d');

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        data: values,
        backgroundColor: metric.color + '88',
        hoverBackgroundColor: metric.color,
        borderColor: metric.color,
        borderWidth: 1,
        borderRadius: 4,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(15, 15, 20, 0.95)',
          borderColor: metric.color + '44',
          borderWidth: 1,
          cornerRadius: 8,
          padding: { top: 10, bottom: 10, left: 14, right: 14 },
          titleFont: { family: "'JetBrains Mono', monospace", size: 12, weight: '400' },
          titleColor: '#888',
          bodyFont: { family: "'JetBrains Mono', monospace", size: 16, weight: '700' },
          bodyColor: metric.color,
          displayColors: false,
          callbacks: {
            title: function(items) {
              var idx = items[0].dataIndex;
              return labels[idx] + ' (' + dailyData[idx].samples + ' samples)';
            },
            label: function(item) { return formatFull(item.parsed.y) + ' avg'; }
          }
        }
      },
      scales: {
        x: {
          ticks: {
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxRotation: 0,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { color: 'rgba(255,255,255,0.08)' },
        },
        y: {
          min: min - pad,
          max: max + pad,
          ticks: {
            callback: function(v) { return formatNumber(v); },
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxTicksLimit: 5,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { display: false },
        }
      },
    }
  });

  return card;
}

/* ── build a daily % change bar card ── */
function buildDailyPctChangeCard(metric, dailyData) {
  // Compute day-over-day percentage changes
  const pctChanges = [];
  const changeLabels = [];
  for (var i = 1; i < dailyData.length; i++) {
    var prev = dailyData[i - 1][metric.key];
    var curr = dailyData[i][metric.key];
    var pct = prev !== 0 ? ((curr - prev) / prev) * 100 : 0;
    pctChanges.push(Math.round(pct * 100) / 100);
    changeLabels.push(dailyData[i].label);
  }

  if (!pctChanges.length) return document.createElement('div');

  var absValues = pctChanges.map(function(v) { return Math.abs(v); });
  var maxAbs = Math.max.apply(null, absValues);
  var pad = maxAbs * 0.15 || 1;

  var avgPct = Math.round(pctChanges.reduce(function(s, v) { return s + v; }, 0) / pctChanges.length * 100) / 100;
  var dayCount = pctChanges.length;

  var card = document.createElement('div');
  card.className = 'card';

  var gradLine = document.createElement('div');
  gradLine.className = 'card-gradient-line';
  gradLine.style.background = 'linear-gradient(90deg,' + metric.gradient[0] + ',' + metric.gradient[1] + ')';
  card.appendChild(gradLine);

  var sign = avgPct >= 0 ? '+' : '';
  var header = document.createElement('div');
  header.className = 'card-header';
  header.innerHTML =
    '<div>' +
      '<div class="metric-label">' + metric.label + '</div>' +
      '<div class="metric-value">' + sign + avgPct.toFixed(2) + '% avg</div>' +
    '</div>' +
    '<div>' +
      '<div class="delta-badge" style="color:' + metric.color + ';background:' + metric.color + '15;">' +
        dayCount + ' day' + (dayCount !== 1 ? 's' : '') + '</div>' +
      '<div class="window-label">daily % change</div>' +
    '</div>';
  card.appendChild(header);

  var wrap = document.createElement('div');
  wrap.className = 'chart-wrap';
  var canvas = document.createElement('canvas');
  wrap.appendChild(canvas);
  card.appendChild(wrap);

  var ctx = canvas.getContext('2d');

  // Color bars green for positive, red for negative
  var barColors = pctChanges.map(function(v) {
    return v >= 0 ? '#4caf50aa' : '#f44336aa';
  });
  var barBorders = pctChanges.map(function(v) {
    return v >= 0 ? '#4caf50' : '#f44336';
  });
  var hoverColors = pctChanges.map(function(v) {
    return v >= 0 ? '#4caf50' : '#f44336';
  });

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: changeLabels,
      datasets: [{
        data: pctChanges,
        backgroundColor: barColors,
        hoverBackgroundColor: hoverColors,
        borderColor: barBorders,
        borderWidth: 1,
        borderRadius: 4,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(15, 15, 20, 0.95)',
          borderColor: metric.color + '44',
          borderWidth: 1,
          cornerRadius: 8,
          padding: { top: 10, bottom: 10, left: 14, right: 14 },
          titleFont: { family: "'JetBrains Mono', monospace", size: 12, weight: '400' },
          titleColor: '#888',
          bodyFont: { family: "'JetBrains Mono', monospace", size: 16, weight: '700' },
          bodyColor: metric.color,
          displayColors: false,
          callbacks: {
            title: function(items) {
              var idx = items[0].dataIndex;
              return changeLabels[idx] + ' vs ' + dailyData[idx].label;
            },
            label: function(item) {
              var v = item.parsed.y;
              var s = v >= 0 ? '+' : '';
              return s + v.toFixed(2) + '%';
            }
          }
        }
      },
      scales: {
        x: {
          ticks: {
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxRotation: 0,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { color: 'rgba(255,255,255,0.08)' },
        },
        y: {
          min: -maxAbs - pad,
          max: maxAbs + pad,
          ticks: {
            callback: function(v) { return v.toFixed(1) + '%'; },
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxTicksLimit: 5,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { display: false },
        }
      },
    }
  });

  return card;
}

/* ── build a daily datapoints card ── */
function buildDailyDatapointsCard(dailyData) {
  var counts = dailyData.map(function(d) { return d.samples; });
  var labels = dailyData.map(function(d) { return d.label; });
  var maxCount = Math.max.apply(null, counts);
  var pad = Math.max(maxCount * 0.15, 2);

  var avgCount = Math.round(counts.reduce(function(s, v) { return s + v; }, 0) / counts.length * 10) / 10;
  var totalPoints = counts.reduce(function(s, v) { return s + v; }, 0);
  var dayCount = counts.length;

  var card = document.createElement('div');
  card.className = 'card';

  var gradLine = document.createElement('div');
  gradLine.className = 'card-gradient-line';
  gradLine.style.background = 'linear-gradient(90deg, #42a5f5, #80d8ff)';
  card.appendChild(gradLine);

  var header = document.createElement('div');
  header.className = 'card-header';
  header.innerHTML =
    '<div>' +
      '<div class="metric-label">Datapoints per Day</div>' +
      '<div class="metric-value">' + avgCount.toFixed(1) + ' avg/day</div>' +
    '</div>' +
    '<div>' +
      '<div class="delta-badge" style="color:#42a5f5;background:#42a5f515;">' +
        totalPoints + ' total · ' + dayCount + 'd</div>' +
      '<div class="window-label">ideal = 24/day</div>' +
    '</div>';
  card.appendChild(header);

  var wrap = document.createElement('div');
  wrap.className = 'chart-wrap';
  var canvas = document.createElement('canvas');
  wrap.appendChild(canvas);
  card.appendChild(wrap);

  var ctx = canvas.getContext('2d');

  // Color bars based on how close to 24 they are
  var barColors = counts.map(function(c) {
    if (c >= 22) return '#4caf50aa';      // green: near-perfect
    if (c >= 16) return '#ffa726aa';      // orange: decent
    return '#f44336aa';                    // red: poor
  });
  var barBorders = counts.map(function(c) {
    if (c >= 22) return '#4caf50';
    if (c >= 16) return '#ffa726';
    return '#f44336';
  });
  var hoverColors = counts.map(function(c) {
    if (c >= 22) return '#4caf50';
    if (c >= 16) return '#ffa726';
    return '#f44336';
  });

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        data: counts,
        backgroundColor: barColors,
        hoverBackgroundColor: hoverColors,
        borderColor: barBorders,
        borderWidth: 1,
        borderRadius: 4,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(15, 15, 20, 0.95)',
          borderColor: '#42a5f544',
          borderWidth: 1,
          cornerRadius: 8,
          padding: { top: 10, bottom: 10, left: 14, right: 14 },
          titleFont: { family: "'JetBrains Mono', monospace", size: 12, weight: '400' },
          titleColor: '#888',
          bodyFont: { family: "'JetBrains Mono', monospace", size: 16, weight: '700' },
          bodyColor: '#42a5f5',
          displayColors: false,
          callbacks: {
            title: function(items) { return labels[items[0].dataIndex]; },
            label: function(item) {
              var v = item.parsed.y;
              var pct = Math.round(v / 24 * 100);
              return v + ' datapoints (' + pct + '% of 24)';
            }
          }
        }
      },
      scales: {
        x: {
          ticks: {
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxRotation: 0,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { color: 'rgba(255,255,255,0.08)' },
        },
        y: {
          min: 0,
          max: Math.max(maxCount + pad, 26),
          ticks: {
            callback: function(v) { return v; },
            color: '#555',
            font: { family: "'JetBrains Mono', monospace", size: 10 },
            maxTicksLimit: 6,
          },
          grid: { color: 'rgba(255,255,255,0.04)', drawTicks: false },
          border: { display: false },
        }
      },
    }
  });

  return card;
}

/* ── state ── */
let cachedData = null;
let activeTab = 'timeline';
let dailyMode = 'absolute'; // 'absolute' or 'pct-change'

function renderCards() {
  const cardsEl = document.getElementById('cards');
  const toggleEl = document.getElementById('daily-toggle');
  cardsEl.innerHTML = '';

  if (!cachedData || !cachedData.length) return;

  if (activeTab === 'timeline') {
    toggleEl.style.display = 'none';
    METRICS.forEach(m => cardsEl.appendChild(buildTimelineCard(m, cachedData)));
  } else if (activeTab === 'daily-datapoints') {
    toggleEl.style.display = 'none';
    const daily = computeDailyAverages(cachedData);
    cardsEl.appendChild(buildDailyDatapointsCard(daily));
  } else {
    toggleEl.style.display = 'flex';
    const daily = computeDailyAverages(cachedData);
    if (dailyMode === 'absolute') {
      METRICS.forEach(m => cardsEl.appendChild(buildDailyAvgCard(m, daily)));
    } else {
      METRICS.forEach(m => cardsEl.appendChild(buildDailyPctChangeCard(m, daily)));
    }
  }
}

/* ── tabs ── */
function setupTabs() {
  const tabsEl = document.getElementById('tabs');
  tabsEl.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      if (this.dataset.tab === activeTab) return;
      tabsEl.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      activeTab = this.dataset.tab;
      renderCards();
    });
  });
}

function setupDailyToggle() {
  const toggleEl = document.getElementById('daily-toggle');
  toggleEl.querySelectorAll('.toggle-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      if (this.dataset.mode === dailyMode) return;
      toggleEl.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      dailyMode = this.dataset.mode;
      renderCards();
    });
  });
}

/* ── main ── */
async function init() {
  const dotEl    = document.getElementById('status-dot');
  const loadEl   = document.getElementById('loading');
  const errEl    = document.getElementById('error');
  const cardsEl  = document.getElementById('cards');
  const subEl    = document.getElementById('subtitle');
  const footerEl = document.getElementById('footer');
  const tabsEl   = document.getElementById('tabs');

  try {
    const res = await fetch(CSV_URL);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const text = await res.text();
    const data = parseCSV(text);

    if (!data.length) throw new Error('CSV is empty');

    cachedData = data;

    dotEl.className = 'status-dot ok';
    loadEl.style.display = 'none';
    cardsEl.style.display = 'flex';
    tabsEl.style.display = 'flex';
    subEl.style.display = 'block';
    footerEl.style.display = 'block';

    const first = new Date(data[0].time);
    const last  = new Date(data[data.length - 1].time);
    const fmt = d => {
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return months[d.getUTCMonth()] + ' ' + d.getUTCDate() + ' ' +
        String(d.getUTCHours()).padStart(2,'0') + ':' +
        String(d.getUTCMinutes()).padStart(2,'0');
    };
    subEl.textContent = fmt(first) + ' → ' + fmt(last) + ' UTC · ' + data.length + ' samples · live from GitHub';

    renderCards();

    const now = new Date();
    footerEl.textContent = 'data pulled live from repo · points positioned by actual timestamp · github.com/gabriel-berzescu/monitoring-the-situation · fetched ' +
      String(now.getUTCHours()).padStart(2,'0') + ':' +
      String(now.getUTCMinutes()).padStart(2,'0') + ' UTC';

  } catch (e) {
    dotEl.className = 'status-dot err';
    loadEl.style.display = 'none';
    errEl.style.display = 'block';
    errEl.textContent = 'Failed to fetch data: ' + e.message;
  }
}

setupTabs();
setupDailyToggle();
init();
setInterval(function() {
  document.getElementById('cards').innerHTML = '';
  init();
}, 5 * 60 * 1000);
</script>
</body>
</html>
